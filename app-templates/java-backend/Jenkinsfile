pipeline {
  triggers {
    githubPush()
    pollSCM('H/15 * * * *')
  }
  parameters {
    string(
          name: 'AWS_TRUST_ROLE',
          defaultValue: env.DEPLOY_ROLE_ARN,
          description: "Role to assume for to deploy application"
      )
    booleanParam(
          name: 'CLEAN_WORKSPACE',
          defaultValue: false,
          description: 'Start with empty workspace'
      )
  }
  agent {
    kubernetes {
      inheritFrom 'toolbox'
      label 'pod'
      containerTemplate(
        name: 'buildbox',
        image: 'openjdk:jdk',
        ttyEnabled: true,
        command: 'cat'
      )
    }
  }
  stages {
    stage('Init') {
      steps {
        script {
          if (params.CLEAN_WORKSPACE) {
            echo "Wiping out workspace"
            deleteDir()
          } else {
            echo 'Skipping cleanup due to user setting'
          }
        }
      }
    }
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Deploy Components') {
      environment {
        HUB_DEBUG = '1'
        NAME = "${params.NAME}"
      }
      steps {
        container('toolbox') {
          script {
            withAWS(role:params.AWS_TRUST_ROLE) {
              hub.elaborate(state: params.STATE_FILE)
              hub.deploy()
            }
          }
        }
      }
    }
    stage('Compile') {
      steps {
        container('buildbox') {
          sh script: './gradlew clean build allureReport'
        }
      }
    }
    stage('Build and Push') {
      steps {
        container('toolbox') {
          script {
            final image = hub.explain().stackOutputs['application.image'] as String
            sh script: "docker build --pull --rm -t ${image}:latest -t ${image}:${gitscm.shortCommit} ."
            withAWS(role:params.AWS_TRUST_ROLE) {
              sh script: ecrLogin()
              sh script: "docker push ${image}:${gitscm.shortCommit}"
              sh script: "docker push ${image}:latest"
            }
          }
        }
      }
    }
    stage('Deploy') {
      environment {
        NAME          = "${params.NAME}"
        NAMESPACE     = "${params.NAMESPACE ?: 'default'}"
        REPLICAS      = "${params.REPLICAS ?: 1}"
        INGRESS_HOST  = "${params.INGRESS_HOST}"
        INGRESS_PATH  = "${params.INGRESS_PATH}"
        HUB_COMPONENT = 'nodejs-application'
      }
      steps {
        container('toolbox') {
          script {
            final image = hub.explain().stackOutputs['application.image']
            final version = "${gitscm.shortCommit}"
            final kubectl = "kubectl -n ${env.NAMESPACE}"

            hub.render template: 'kubernetes.yaml.template',
                       additional: [
                        'application.image': image,
                        'application.version': version,
                      ]

            echo readFile('kubernetes.yaml')

            final exists = sh script: "${kubectl} get -f kubernetes.yaml", returnStatus: true
            try {
              if (exists == 0) {
                sh script: "${kubectl} set image --record 'deployment/${params.NAME}' 'application=${image}:${version}'"
              } else {
                sh script: "${kubectl} apply --force --record -f kubernetes.yaml"
              }
            } catch (err) {
              echo "Rolling back"
              sh script: "${kubectl} rollout undo 'deployment/${params.NAME}'"
              sh script: "${kubectl} rollout status -w 'deployment/${params.NAME}'"
              echo "Done"
              error "Failed to deploy ${params.NAME}@${version}. Rolled back"
            }
          }
        }
      }
    }
    stage('Validate') {
      steps {
        script {
          retry(30) {
            sleep time: 3, unit: 'SECONDS'
            final resp = httpRequest url: "http://${params.INGRESS_HOST}/status"
            echo resp.content
            assert resp.status == 200
          }
        }
      }
    }
  }
  post {
    always {
      junit(
        testResults: './tests-*.xml',
        allowEmptyResults: true
      )
      archiveArtifacts(
        artifacts: 'build/libs/*.jar',
        allowEmptyArchive: true,
        fingerprint: true
      )
      publishHTML(target: [
              reportDir: 'build/reports/allure-report',
              reportFiles: 'index.html',
              reportName: 'Allure',
              keepAll: true
      ])
    }
    changed {
      slackSend color: slack.buildColor, message: slack.buildReport(htmlReports: ['Allure'])
    }
  }
}
